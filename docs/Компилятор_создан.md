

Тег step-9 — это закладка. Перейдя по ней, можно посмотреть код.

### 1. Архитектурная схема (Pipeline)

Компилятор работает как конвейер из 4-х этапов. Данные входят как «сырой» JSON из Blockly и выходят как готовый конфиг сайта.

#### **Этап I: Parser (Нормализатор)**

* **Задача:** Превратить древовидную структуру Blockly (где блоки вложены друг в друга через `children` и `next`) в **плоский список задач** (`tasks`).
* **Что делает:** Рекурсивно обходит каждый блок, извлекает его полезную нагрузку (`data`) и, самое главное, назначает каждому блоку `parentId`.
* **Результат:** Массив объектов, где у каждого блока есть свой ID и ID его родителя.

#### **Этап II: Validator (Фильтр и проверка правил)**

* **Задача:** Очистить проект от «мусора» и проверить семантику (правила вложенности).
* **Что делает:** 1. Находит корень (`home_container`).
2. Используя **White List** (карту разрешенных вложений), отсекает блоки, которые находятся не на своем месте (например, если ты положил группу в группу или принт в корень).
* **Результат:** Только те блоки, которые допущены к «публикации».

#### **Этап III: Transformer (Сборщик дерева AST)**

* **Задача:** Восстановить иерархию, но уже на основе очищенных данных.
* **Что делает:** Пробегается по плоскому списку и, используя карту соответствий, вкладывает «детей» в массивы `children` их «родителей».
* **Результат:** **Abstract Syntax Tree (AST)** — идеальное дерево проекта без лишних технических полей.

#### **Этап IV: Assembler (Генератор конфига)**

* **Задача:** Придать данным финальный вид, который понимает твой фронтенд.
* **Что делает:** 1. Обращается к **Mapping** (справочнику блоков), чтобы узнать, какой «заголовок» или «картинку» назначить блоку по его ID.
2. Вызывает **Signatures** (сигнатуры) — специальные функции-фабрики, которые создают объекты `row`, `image` или `text` с четко заданными именами полей (`rowId`, `blocks` и т.д.).
* **Результат:** Финальный JSON-объект сайта.

---

### 2. Ключевые компоненты системы

| Компонент | Роль в системе |
| --- | --- |
| **Signatures** | Гарантируют, что структура данных всегда будет одинаковой и не «сломает» фронтенд. |
| **Blocks Mapping** | Позволяет менять контент (тексты, пути к фото) без переписывания логики компилятора. |
| **Debug Print** | Наш инструмент визуализации, который рисует текстовую «лесенку» в консоли для быстрой проверки. |

---



### 3. Ключевые преимущества архитектуры

Использование многоэтапного конвейера обработки данных обеспечивает стабильность и гибкость системы при разработке визуального конструктора.

#### **Масштабируемость и расширяемость**

Архитектура спроектирована по принципу открытости/закрытости (Open/Closed Principle). Добавление новых функциональных блоков в Blockly не требует внесения изменений в логику парсера или трансформатора. Расширение системы происходит декларативно через:

* Регистрацию новой функции в **Signatures** (определение структуры данных).
* Добавление записи в **Blocks Mapping** (связывание визуального блока с его логическим представлением).

#### **Отказоустойчивость и семантическая безопасность**

Наличие этапа валидации гарантирует чистоту выходных данных. Система автоматически игнорирует:

* «Мусорные» блоки (объекты, не имеющие связи с корневым контейнером).
* Нарушения правил вложенности (семантические ошибки, когда структура блоков в Blockly противоречит логике бизнес-процесса).
Это исключает возможность поломки фронтенд-рендерера из-за некорректных действий пользователя.

#### **Прозрачность процесса (Observability)**

Разделение компиляции на атомарные стадии позволяет точно диагностировать проблемы на каждом этапе жизненного цикла данных:

1. **Parser:** Проверка корректности чтения JSON-строки.
2. **Validator:** Идентификация отсеченных блоков.
3. **Transformer:** Контроль корректности построения AST-дерева.
4. **Assembler:** Проверка финального маппинга и сигнатур.
Детальное логирование каждой стадии значительно сокращает время на поиск и устранение ошибок в логике компиляции.

---

### Что мы имеем на выходе?

На выходе получается объект, который ты просто отдаешь в Vue-компонент, и он отрисовывает сайт:

```typescript
{
  id: "container_home",
  rowId: "container_01",
  rowTitle: "Верхняя секция",
  blocks: [
    { id: "block_01", type: "image", title: "Блок 1", data: { src: "/assets/b1.png" } }
  ]
}

```
