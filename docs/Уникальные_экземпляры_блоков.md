### Что получилось — видео, условия задачи (см. ниже)
[Уникальные экземпляры блоков.webm](https://github.com/user-attachments/assets/895c4685-2780-4a0a-87b3-6451ce53e4c8)

### Функциональные требования к блокам "Print"

Тег step-6 — это закладка. Перейдя по ней, можно посмотреть код.

**1. Уникальные экземпляры блоков**
- Каждый блок должен иметь предопределенный уникальный идентификатор (ID) — например: `block1`, `block2`, `block3`.
- Блоки с фиксированными ID существуют в единственном экземпляре.

**2. Поведение при перетаскивании**
- При перетаскивании блока из палитры (вкладка "Мои блоки") на рабочую область:
  - Блок появляется на рабочем столе.
  - Блок **исчезает из палитры**.
- Повторное перетаскивание того же блока невозможно, пока он находится на рабочей области.

**3. Поведение при удалении**
- При удалении блока с рабочей области:
  - Блок **возвращается в палитру** (вкладка "Мои блоки").
  - Становится доступным для повторного использования.

**4. Отображение в палитре**
- В палитре блоки должны отображаться с понятными именами: «Блок 1», «Блок 2», «Блок 3».
- Палитра всегда показывает только те блоки, которые в данный момент **не находятся** на рабочей области.

**5. Предсказуемые ID**
- ID блоков жестко заданы разработчиком, не генерируются динамически.
- Сохраняются на протяжении всей сессии работы редактора.

---------------------------------------------

### 1. Динамический Toolbox (Dynamic Categories)

Вместо статичного JSON-файла с тулбоксом, мы используем функцию-колбэк. Blockly будет вызывать её каждый раз, когда пользователь открывает вкладку «Мои блоки». Эта функция будет проверять: «Какие блоки из списка [1, 2, 3] сейчас НЕ находятся на рабочем столе?» и показывать только их.

### 2. Синхронизация через события (Events)

Мы вешаем слушатель на события `BLOCK_CREATE` и `BLOCK_DELETE`:

* Как только вы перетащили «Блок 1» на поле — срабатывает триггер, мы помечаем его как «занятый» и принудительно обновляем тулбокс. Он исчезает из списка доступных.
* Как только вы удалили его в корзину — помечаем как «свободный», и он возвращается в меню.

### 3. Фиксация ID (Static IDs)

Чтобы ID были предсказуемыми (1, 2, 3), а не случайными строками типа `jR5x!9...`, при создании блока в тулбоксе мы заранее прописываем ему конкретный `id`. Когда вы тянете блок из панели, Blockly может либо сохранить этот ID, либо мы можем принудительно назначить его в момент приземления блока на рабочую область.

### 4. Визуальное отличие

Чтобы блоки в тулбоксе назывались «Блок 1», «Блок 2», можно использовать поле `NAME` или `TITLE`. Можно даже сделать их разного цвета, чтобы пользователю было легче ориентироваться, какой именно экземпляр он уже использовал.

### Резюме:

Это отличный подход для систем конфигурации (например, если у вас есть 3 конкретных датчика или 3 конкретных мотора, и вы не можете добавить четвертый, которого нет в реальности).
