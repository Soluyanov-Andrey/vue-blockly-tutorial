## Документация: Генерация JSON-структуры в реальном времени

Тег step-4 — это закладка. Перейдя по ней, можно посмотреть код.

### 1. Обзор системы

Реализованный функционал позволяет автоматически преобразовывать визуальную схему блоков в структурированный JSON-массив при каждом изменении на рабочем поле (workspace). Это необходимо для передачи данных на бэкенд или выполнения логики во внешних системах.

### 2. Структура файлов

* **`src/generators/json.ts`**: Сердце системы. Содержит определение кастомного генератора `jsonGenerator` и правила преобразования для каждого типа блока.
* **`src/composables/useBlockly.ts`**: Управляет жизненным циклом Blockly и связывает события изменения поля с функцией генерации.

---

### 3. Логика генератора (`json.ts`)

В отличие от стандартных генераторов (JavaScript/Python), данный генератор возвращает фрагменты JSON-строк, которые затем собираются в единое дерево.

#### Ключевые принципы:

* **Иерархия (Next Blocks):** Каждый блок рекурсивно опрашивает своего соседа снизу через `block.getNextBlock()`. Если сосед существует, он вкладывается в текущий объект под ключом `"next"`.
* **Приоритеты (Order):** Для корректной работы `valueToCode` определены константы `ORDER_ATOMIC` и `ORDER_NONE`.
* **Сборка (`generateWorkspaceJson`):**
1. Находит все «корневые» блоки (те, у которых нет родителя сверху).
2. Вызывает генерацию для каждой независимой цепочки.
3. Парсит строки в объекты и возвращает массив JSON.



---

### 4. Механизм отслеживания событий (`useBlockly.ts`)

Для того чтобы консоль обновлялась автоматически, используется слушатель событий Blockly.

#### Процесс обновления:

1. **Подписка:** В хуке `onMounted` вызывается `workspace.value.addChangeListener(handleWorkspaceChange)`.
2. **Фильтрация:** Система игнорирует события интерфейса (`event.isUiEvent`), такие как открытие палитры блоков, чтобы избежать лишних вычислений.
3. **Реакция:** События типа `BLOCK_MOVE`, `BLOCK_CHANGE`, `BLOCK_CREATE` и `BLOCK_DELETE` инициируют вызов генератора.

---

### 5. Формат выходных данных

Результат выводится в консоль в виде массива объектов. Пример для двух соединенных блоков:

```json
[
  {
    "type": "custom_print",
    "id": "unique_id_1",
    "message": "Первый блок",
    "next": {
      "type": "custom_print",
      "id": "unique_id_2",
      "message": "Второй блок"
    }
  }
]

```

---

### 6. Устранение ошибок (Troubleshooting)

* **Ошибка `TypeError: Expecting valid order**`: Возникает, если в генераторе не указан приоритет операций. Решено добавлением `jsonGenerator.ORDER_ATOMIC`.
* **Ошибка `SyntaxError: Expected property name**`: Возникала при попытке парсинга некорректно склеенных строк. Решено переходом на рекурсивную сборку внутри функций блоков и очисткой метода `scrub_`.

---
